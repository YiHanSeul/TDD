## 구조적 테스트와 코드 커버리지
  2장에서는 테스트를 도출하는 주요 요소로서 소프트웨어 요구사항을 사용하는 것에 대해 공부했고, 명세기반 테스트가 완료되면 다음 단계는 <b> 소스 코드를 활용해서 테스트 스위트를 확장</b> 한다.

  - 요구사항을 분석할 때 한두 개 구획을 빼먹어도 소스 코드를 보는동안 이 점을 알아 차릴 수 있다.
  - 코드를 구현할 때는 문서에 명시되어 있지 않은 언어 구조, 알고리즘 및 데이터 구조를 활용한다.
---
### 💡구조적 테스트란?
소스코드를 체계적으로 활용하는 방법과 명세를 통해 도출한 테스트 스위트를 수행할 때 일어나는 일. 그리고 남아있는 테스트가 무엇인지를 확인하고 소스코드의 구조를 사용하여 테스트를 도출하는 것을 <b>구조적 테스트</b>라고 한다. <br>
-> 구조적 테스트 기법을 이해한다는 것은 커버리지 기준을 이해한다는 뜻이다.

---

### 💡코드 커버리지, 올바른 방법
테스트가 코드의 어느 부분을 수행하는지 찾아내는 일이 간단하다.<br> 모든 프로그래밍 언어 및 환경에 관한 코드 커버리지 도구가 출시되어 있기 때문이다.<br>
ex) 자코코(www.jacoco.org/jacoco)
자코코는 분기가 일어나거나 테스트 코드 수행여부에 따라 색으로 표시한다.

---
### 💡구조적 테스트 간략히 살펴보기
1. <b>명세 기반 테스트</b>를 수행한다.(2장)
2. <b>구현사항을 읽고</b>, 개발자의 주요 결정사항을 이해하자
3. 고안했던 테스트 케이스를 <b>코드 커버리지 도구</b>로 수행하자
4. 테스트가 수행되지 <b>않은</b> 코드에대해
   1. 왜 그 코드가 수행되지 않았는지 <b>이해하자.</b>
   2. 그 코드가 테스트할 가치가 있는지 <b>결정하자.</b>
   3. 테스트가 필요하다면 놓친 코드조각을 수행하는 <b>자동화된 테스트 케이스를 구현하자</b>
5. 소스 코드를 바탕으로 <b>고안할 만한 다른 흥미로운 테스트가 있는지 찾아보자</b>

>구조적 테스트는 이전의 명세 기반 테스트로 고안한 테스트 스위트를 보강한다.

---
### 💡코드 커버리지 기준
**1. 코드 줄 커버리지**
- 테스트가 적어도 하나를 존재하기 원함

**2. 분기커버리지**
- 분기 지시문(if, for, while등)이 어떻게 평가되는지에 따라 프로그램을 다르게 동작한다는 점을 고려한다.

**3. 조건 + 분기 커버리지**
- 조건 + 분기 커버리지는 분기 뿐만 아니라 분기문의 각 조건도 고려한다. 조건을 true 또는 false로 만족하는 테스트를 적어도 하나 만들어야 된다. 그리고 전체 분기문을 또는 true 또는 false로 만족하도록 하는 테스트를 적어도 하나 만들어야 된다.

**4. 경로 커버리지**
- 경로 커버리지를 목표로 하는 개발자는 프로그램이 수행할 수 있는 모든 실행 경로를 수행한다.

---

### 💡 복잡한 조건과 MC/DC 커버리지 기준
- 테스트 스위트를 구툭하기 위한 노력과 비용을 최소화하면서 찾아낼 수 있는 버그 수 를 최대화하는 일은 모든 테스터가 해야 할 일의 일부다. **복잡하고 긴 if문에 대해 무엇을 할 수 있을까? 이질문에 대한 좋은 대답은 수정된 조건/의사결정 커버리지 MC/DC를 적용하는것이다.**
- MC/DC의 기준은 경로 커버리지와 마찬가지로 조거느이 조합을 살펴본다. 그러나 **가능한 모든 조합을 테스트하는 대신 테스트가 필요한 중요한 조합을 찾아낸다.**

---

### 💡 반복문과 유사 구조 처리하기
반복문은 완벽한 테스트는 불가능하기 때문에 테스터는 종종 **반복 경계 적합 기준**을 적용해서 언제 반복 테스트를 중지할지 결정한다.
테스트 스위트는 반복문에 대해서만 이 기준을 만족하도록 한다.
- 반복문을 0번 수행하는 테스트 케이스
- 반복문을 1번 수행하는 테스트 케이스
- 반복문을 여러번 수행하는 테스트 케이스

---

### 💡 기준 포함과 선택
일부 전략은 다른 전략을 포함한다.

코드 줄 커버리지 < 분기 커버리지, 조건 커버리지 < 분기 + 조건 커버리지 < MC/DC < 경로 커버리지

취약한 기준은 비용이 적고 빠르게 수행할 수 있지만 코드가 수행하지 않는 부분을 많이 남기게 된다. 반면에 탄탄한 기준은 비용을 많이 들여서 더 엄격하게 코드를 수행할 수 있다. 어떤 기준을 선택할지는 개발자인 우리의 몫이다.

---
### 💡일부 전략은 다른 전략을 포함한다.

코드 줄 커버리지 < 분기 커버리지, 조건 커버리지 < 분기 + 조건 커버리지 < MC/DC < 경로 커버리지

취약한 기준은 비용이 적고 빠르게 수행할 수 있지만 코드가 수행하지 않는 부분을 많이 남기게 된다. 반면에 탄탄한 기준은 비용을 많이 들여서 더 엄격하게 코드를 수행할 수 있다. 어떤 기준을 선택할지는 개발자인 우리의 몫이다.

---
### 💡구조적 테스트만 적용하는 것은 충분하지 않다.
- 분기커버리지를 100% 달성을 해도 테스트케이스를 많이 빼먹는다. 그리고 특이 케이스는 순수한 구조적 테스트로는 얻을 수 없다.

---
### 💡돌연변이 테스트
커버리지만으로는 테스트 스위트의 품질을 알 수 없다. 테스트 스위트의 오류 감지 능력을 생각해보자 얼마나 많은 버그를 드러낼 수 있을까? 라는게 돌연변이 테스트에 깔려 있는 개념이다. 간단히 말해서 **존재하는 코드에 일부러 버그를 주입해서 테스트 스위트가 깨지는지 검사한다.** 돌연변이 테스트는 비싼 비용에도 불구하고 매우 유익하다. 구글과 같은 대기업도 돌연변이 테스트에 투자하고 있다고 한다.시스템에서 좀 더 민감한 부분에 대해 적용해보면 좋을 것 같다.